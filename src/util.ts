import { downloadZip } from 'client-zip';
import fileSaver from 'file-saver';
import normalize from 'normalize-path'
import { getSource } from './service';

export const getSourceMaps = async (scriptList: string[], onUpdate: { (currentIndex: number): void; (arg0: number): void; }) => {
  let error = '';
  const combinedSourceMap : {sources: string[], sourcesContent: string[]} = { sources: [], sourcesContent: [] };
  try {
    if (!scriptList.length) {
      throw new Error('No scripts found on page');
    }
    const reutrnedSources = [];

    // run in series
    for (let i = 0; i < scriptList.length; i++) {
      const url = scriptList[i];
      const resp = await getSource(url).catch((e) => {
        console.error('Failed for -', url);
        if (e instanceof Error) {
          if (e instanceof Error) {
            console.error(e.message);
          } else {
            console.error('An unknown error occurred:', e);
          }
        } else {
          console.error('An unknown error occurred:', e);
        }
      });
      onUpdate(i);

      // add delay
      await new Promise((resolve) => setTimeout(resolve, 100));
      if (resp) {
        reutrnedSources.push(resp);
      }
    }

    reutrnedSources.forEach((d) => {
      combinedSourceMap.sources = combinedSourceMap.sources.concat(d.sources as string[]);
      combinedSourceMap.sourcesContent =
        combinedSourceMap.sourcesContent.concat(d.sourcesContent as string[]);
    });

    // Flatten all extra ../../ to show more content more meaningfully
    const regex = /^(\.\.\/)+/gm;
    combinedSourceMap.sources = combinedSourceMap.sources.map(path => path && normalize(path).replace(regex, '').replace('/./', '/')).filter(i => !!i);
  } catch (e) {
    if (e instanceof Error) {
      if (e instanceof Error) {
        console.error(e.message);
        error = e.message;
      } else {
        console.error('An unknown error occurred:', e);
        error = 'An unknown error occurred';
      }
    } else {
      console.error('An unknown error occurred:', e);
      error = 'An unknown error occurred';
    }
  }

  return {
    list: scriptList,
    combinedSourceMap,
    error: error.length
      ? error
      : combinedSourceMap.sources.length === 0
      ? 'No map files found'
      : '',
  };
};

export async function downloadCode(filePaths: string[], fileContents: string[], url: string | URL) {
  const blob = await packFiles(filePaths, fileContents);
  const zipName = new URL(url).hostname;
  if (blob) {
    fileSaver.saveAs(blob, `${zipName}-code.zip`);
  } else {
    console.error('Blob is undefined, cannot save file.');
  }
}

export async function packFiles(filePaths: unknown[], fileContents: string[]) {
  const intro = {
    name: 'BANNER.txt',
    lastModified: new Date(),
    input: `Generated by ${location.origin}.`,
  };
  const files = [intro];

  (filePaths as { replaceAll: (arg0: string, arg1: string) => string }[]).forEach((path, index) => {
      const sanitizedPath = path.replaceAll('..', 'other');
      files.push({
        name: sanitizedPath,
        lastModified: new Date(),
        input: fileContents[index] || '',
      });
    });
  let blob;
  // get the ZIP stream in a Blob
  try {
    blob = await downloadZip(files).blob();
  } catch (e) {
    console.error(e);
    console.error('Error in downloading');
  }
  return blob;
}
