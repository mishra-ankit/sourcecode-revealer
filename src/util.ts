import { downloadZip } from 'client-zip';
import fileSaver from 'file-saver';
import normalize from 'normalize-path'
import { getSource } from './service';

export const getSourceMaps = async (scriptList, onUpdate) => {
  let error = '';
  const combinedSourceMap : {sources: string[], sourcesContent: string[]} = { sources: [], sourcesContent: [] };
  try {
    if (!scriptList.length) {
      throw new Error('No scripts found on page');
    }
    const reutrnedSources = [];

    // run in series
    for (let i = 0; i < scriptList.length; i++) {
      const url = scriptList[i];
      const resp = await getSource(url).catch((e) => {
        console.error('Failed for -', url);
      });
      onUpdate(i);

      // add delay
      await new Promise((resolve) => setTimeout(resolve, 100));
      if (resp) {
        reutrnedSources.push(resp);
      }
    }

    reutrnedSources.forEach((d) => {
      combinedSourceMap.sources = combinedSourceMap.sources.concat(d.sources);
      combinedSourceMap.sourcesContent =
        combinedSourceMap.sourcesContent.concat(d.sourcesContent);
    });

    // Flatten all extra ../../ to show more content more meaningfully
    const regex = /^(\.\.\/)+/gm;
    combinedSourceMap.sources = combinedSourceMap.sources.map(path => path && normalize(path).replace(regex, '').replace('/./', '/')).filter(i => !!i);
  } catch (e) {
    console.error(e.message);
    error = e.message;
  }

  return {
    list: scriptList,
    combinedSourceMap,
    error: error.length
      ? error
      : combinedSourceMap.sources.length === 0
      ? 'No map files found'
      : '',
  };
};

export async function downloadCode(filePaths, fileContents, url) {
  const blob = await packFiles(filePaths, fileContents);
  const zipName = new URL(url).hostname;
  fileSaver.saveAs(blob, `${zipName}-code.zip`);
}

export async function packFiles(filePaths, fileContents) {
  const intro = {
    name: 'BANNER.txt',
    lastModified: new Date(),
    input: `Generated by ${location.origin}.`,
  };
  const files = [intro];

  filePaths.forEach((path, index) => {
    const sanitizedPath = path.replaceAll('..', 'other');
    files.push({
      name: sanitizedPath,
      lastModified: new Date(),
      input: fileContents[index] || '',
    });
    // }
  });
  let blob;
  // get the ZIP stream in a Blob
  try {
    blob = await downloadZip(files).blob();
  } catch (e) {
    console.error(e);
    console.error('Error in downloading');
  }
  return blob;
}
